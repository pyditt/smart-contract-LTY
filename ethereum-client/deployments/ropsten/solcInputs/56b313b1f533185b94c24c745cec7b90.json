{
  "language": "Solidity",
  "sources": {
    "contracts/_mock/MockERC20.sol": {
      "content": "pragma solidity ^0.6.12;\n\n\n// Only for testing purposes!!!\ncontract MockERC20 {\n    string  public name;\n    string  public symbol;\n    uint256 public totalSupply;\n    uint8   public constant decimals = 18;\n\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    constructor(string memory name_, string memory symbol_) public {\n        name = name_;\n        symbol = symbol_;\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) external returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function mint(address account, uint256 amount) external {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        totalSupply += amount;\n        balanceOf[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n}\n"
    },
    "contracts/_mock/MockTokens.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport \"../interfaces/IReserve.sol\";\n\ncontract MockUSDC is MockERC20 {\n    constructor() public MockERC20(\"MockUSDC\", \"MUSDC\") { }\n}\n\ncontract MockLedgity is MockERC20 {\n    IReserve reserve;\n\n    constructor() public MockERC20(\"MockLedgity\", \"MLTY\") { }\n\n    function setReserve(address _reserve) external {\n        reserve = IReserve(_reserve);\n    }\n\n    function swapAndCollect(uint256 tokenAmount) external {\n        reserve.swapAndCollect(tokenAmount);\n    }\n\n    function swapAndLiquify(uint256 tokenAmount) external {\n        reserve.swapAndLiquify(tokenAmount);\n    }\n\n    function burn(uint256 amount) external returns (bool) {\n        require(balanceOf[msg.sender] >= amount, \"MockLedgity: non enough tokens to burn\");\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n        return true;\n    }\n}\n"
    },
    "contracts/interfaces/IReserve.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./IUniswapV2Pair.sol\";\n\n\ninterface IReserve {\n    function uniswapV2Pair() external returns (IUniswapV2Pair);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function swapAndCollect(uint256 tokenAmount) external;\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function swapAndLiquify(uint256 tokenAmount) external;\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function buyAndBurn(uint256 usdcAmount) external;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event BuyAndBurn(uint256 tokenAmount, uint256 usdcAmount);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event SwapAndCollect(uint256 tokenAmount, uint256 usdcAmount);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event SwapAndLiquify(\n        uint256 tokenSwapped,\n        uint256 usdcReceived,\n        uint256 tokensIntoLiqudity\n    );\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/Reserve.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./libraries/Ownable.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IUniswapV2Router02.sol\";\nimport \"./interfaces/ILedgity.sol\";\nimport \"./interfaces/IReserve.sol\";\n\n\ncontract Reserve is IReserve, Ownable {\n    using SafeMath for uint256;\n\n    IUniswapV2Router02 public uniswapV2Router;\n    IUniswapV2Pair public override uniswapV2Pair;\n    ILedgity public token;\n    IERC20 public usdc;\n    address public immutable timelock;\n\n    modifier onlyToken {\n        require(msg.sender == address(token), \"Reserve: caller is not the token\");\n        _;\n    }\n\n    constructor(address uniswapRouter, address TOKEN, address USDC, address timelock_) public {\n        require(timelock_ != address(0), \"Reserve: invalid timelock address\");\n        uniswapV2Router = IUniswapV2Router02(uniswapRouter);\n        token = ILedgity(TOKEN);\n        usdc = IERC20(USDC);\n        timelock = timelock_;\n        uniswapV2Pair = IUniswapV2Pair(\n            IUniswapV2Factory(IUniswapV2Router02(uniswapRouter).factory())\n                .createPair(TOKEN, USDC)\n        );\n    }\n\n    function buyAndBurn(uint256 usdcAmount) external override onlyOwner {\n        address[] memory path = new address[](2);\n        path[0] = address(usdc);\n        path[1] = address(token);\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        SafeERC20.safeApprove(address(usdc) ,address(uniswapV2Router), usdcAmount);\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            usdcAmount,\n            0, // accept any amount of token\n            path,\n            address(this),\n            block.timestamp\n        );\n        uint256 tokensSwapped = token.balanceOf(address(this)).sub(tokenBalanceBefore);\n        require(token.burn(tokensSwapped), \"Reserve: burn failed\");\n        emit BuyAndBurn(tokensSwapped, usdcAmount);\n    }\n\n    function swapAndCollect(uint256 tokenAmount) external override onlyToken {\n        uint256 usdcReceived = _swapTokensForUSDC(tokenAmount);\n        emit SwapAndCollect(tokenAmount, usdcReceived);\n    }\n\n    function swapAndLiquify(uint256 tokenAmount) external override onlyToken {\n        uint256 tokenBalance = token.balanceOf(address(this));\n        uint256 half = tokenAmount;\n        uint256 otherHalf = tokenAmount;\n        if (tokenBalance < tokenAmount.mul(2)) {\n            half = tokenBalance.div(2);\n            otherHalf = tokenBalance.sub(half);\n        }\n\n        uint256 usdcReceived = _swapTokensForUSDC(otherHalf);\n        // Add liquidity mannualy instead of using the router.\n        // This allows us to add liquidity in proportion we want, regardless of current pool reserves.\n        // Adding liquidity must:\n        //   1. Transfer both tokens to the pair\n        //   2. Mint LP tokens to some address.\n        SafeERC20.safeTransfer(address(token), address(uniswapV2Pair), half);\n        SafeERC20.safeTransfer(address(usdc), address(uniswapV2Pair), usdcReceived);\n        uniswapV2Pair.mint(timelock);\n        emit SwapAndLiquify(otherHalf, usdcReceived, half);\n    }\n\n    function _swapTokensForUSDC(uint256 tokenAmount) private returns (uint256) {\n        address[] memory path = new address[](2);\n        path[0] = address(token);\n        path[1] = address(usdc);\n        uint256 usdcBalanceBefore = usdc.balanceOf(address(this));\n        SafeERC20.safeApprove(address(token) ,address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of USDC\n            path,\n            address(this),\n            block.timestamp\n        );\n        uint256 usdcSwapped = usdc.balanceOf(address(this)).sub(usdcBalanceBefore);\n        return usdcSwapped;\n    }\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./Context.sol\";\n\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () public {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "pragma solidity ^0.6.12;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"../interfaces/IERC20.sol\";\n\n\nlibrary SafeERC20 {\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'SafeERC20::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'SafeERC20::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'SafeERC20::safeApprove: approve failed'\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/ILedgity.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./IERC20.sol\";\n\n\ninterface ILedgity is IERC20 {\n    function burn(uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/libraries/Context.sol": {
      "content": "pragma solidity ^0.6.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/LedgityRouter.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./interfaces/IUniswapV2Router02.sol\";\nimport \"./interfaces/ILedgity.sol\";\nimport \"./interfaces/ILedgityRouter.sol\";\n\n\ncontract LedgityRouter is ILedgityRouter {\n    IUniswapV2Factory public immutable factory;\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    constructor(address _router) public {\n        IUniswapV2Router02 _uniswapRouter = IUniswapV2Router02(_router);\n        factory = IUniswapV2Factory(_uniswapRouter.factory());\n        uniswapRouter = _uniswapRouter;\n    }\n\n    function addLiquidityBypassingFee(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\n        SafeERC20.safeTransferFrom(tokenA, msg.sender, address(this), amountADesired);\n        SafeERC20.safeTransferFrom(tokenB, msg.sender, address(this), amountBDesired);\n        SafeERC20.safeApprove(tokenA, address(uniswapRouter), amountADesired);\n        SafeERC20.safeApprove(tokenB, address(uniswapRouter), amountBDesired);\n        (amountA, amountB, liquidity) = uniswapRouter.addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin, to, deadline);\n        _refund(tokenA, msg.sender);\n        _refund(tokenB, msg.sender);\n    }\n\n    function removeLiquidityBypassingFee(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountA, uint256 amountB) {\n        address pair = factory.getPair(tokenA, tokenB);\n        SafeERC20.safeTransferFrom(pair, msg.sender, address(this), liquidity);\n        SafeERC20.safeApprove(pair, address(uniswapRouter), liquidity);\n        (amountA, amountB) = uniswapRouter.removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, address(this), deadline);\n        _refund(tokenA, to);\n        _refund(tokenB, to);\n    }\n\n    function _refund(address token, address to) private {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance != 0) {\n            SafeERC20.safeTransfer(token, to, balance);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ILedgityRouter.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface ILedgityRouter {\n    function addLiquidityBypassingFee(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function removeLiquidityBypassingFee(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n}\n"
    },
    "contracts/Ledgity.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./libraries/ReflectToken.sol\";\nimport \"./libraries/Percent.sol\";\nimport \"./libraries/Set.sol\";\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IUniswapV2Router02.sol\";\nimport \"./interfaces/ILedgity.sol\";\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/ILedgityPriceOracle.sol\";\n\n\ncontract Ledgity is ILedgity, ReflectToken {\n    using SafeMath for uint256;\n    using Percent for Percent.Percent;\n    using Set for Set.AddressSet;\n\n    uint256 public constant initialTotalSupply = 2760000000 * 10**18;\n\n    uint256 public numTokensToSwap;\n    bool public inSwapAndLiquify;\n    enum FeeDestination {\n        Liquify,\n        Collect\n    }\n    FeeDestination public feeDestination = FeeDestination.Liquify;\n    Percent.Percent public sellAccumulationFee = Percent.encode(6, 100);\n    Percent.Percent public initialSellAccumulationFee = sellAccumulationFee;\n    Percent.Percent public sellAtSmallPriceAccumulationFee = Percent.encode(6 + 15, 100);\n    Percent.Percent public initialSellAtSmallPriceAccumulationFee = sellAtSmallPriceAccumulationFee;\n    Percent.Percent public sellReflectionFee = Percent.encode(4, 100);\n    Percent.Percent public initialSellReflectionFee = sellReflectionFee;\n    Percent.Percent public buyAccumulationFee = Percent.encode(4, 100);\n    Percent.Percent public initialBuyAccumulationFee = buyAccumulationFee;\n    Set.AddressSet private _dexes;\n    Set.AddressSet private _excludedFromDexFee;\n\n    Set.AddressSet private _excludedFromLimits;\n    mapping(address => uint256) public lastTransactionAt;\n    Percent.Percent public maxTransactionSizePercent = Percent.encode(25, 10000);\n\n    IUniswapV2Pair public uniswapV2Pair;\n    IReserve public reserve;\n    ILedgityPriceOracle public priceOracle;\n    uint256 public initialPrice;\n\n    constructor() public ReflectToken(\"Ledgity\", \"LTY\", initialTotalSupply) {\n        numTokensToSwap = totalSupply().mul(15).div(10000);\n        setIsExcludedFromDexFee(owner(), true);\n        setIsExcludedFromDexFee(address(this), true);\n        setIsExcludedFromLimits(owner(), true);\n        setIsExcludedFromLimits(address(this), true);\n        excludeAccount(address(this));\n    }\n\n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n\n    function initializeReserve(address reserveAddress) external onlyOwner {\n        reserve = IReserve(reserveAddress);\n        setIsExcludedFromDexFee(address(reserve), true);\n        setIsExcludedFromLimits(address(reserve), true);\n        excludeAccount(address(reserve));\n        uniswapV2Pair = reserve.uniswapV2Pair();\n        setDex(address(uniswapV2Pair), true);\n    }\n\n    function initializePriceOracle(address priceOracleAddress) external onlyOwner {\n        priceOracle = ILedgityPriceOracle(priceOracleAddress);\n        if (initialPrice == 0) {\n            initialPrice = _getPrice();\n        }\n    }\n\n    function totalBurn() external view returns (uint256) {\n        return initialTotalSupply - totalSupply();\n    }\n\n    function setDex(address target, bool dex) public onlyOwner {\n        if (dex) {\n            _dexes.add(target);\n            if (!isExcluded(target)) {\n                excludeAccount(target);\n            }\n        } else {\n            _dexes.remove(target);\n            if (isExcluded(target)) {\n                includeAccount(target);\n            }\n        }\n    }\n\n    function setFeeDestination(FeeDestination fd) public onlyOwner {\n        feeDestination = fd;\n    }\n\n    function setIsExcludedFromDexFee(address account, bool isExcluded) public onlyOwner {\n        if (isExcluded) {\n            _excludedFromDexFee.add(account);\n        } else {\n            _excludedFromDexFee.remove(account);\n        }\n    }\n\n    function setIsExcludedFromLimits(address account, bool isExcluded) public onlyOwner {\n        if (isExcluded) {\n            _excludedFromLimits.add(account);\n        } else {\n            _excludedFromLimits.remove(account);\n        }\n    }\n\n    function setNumTokensToSwap(uint256 _numTokensToSwap) external onlyOwner {\n        numTokensToSwap = _numTokensToSwap;\n    }\n\n    function setMaxTransactionSizePercent(uint128 numerator, uint128 denominator) external onlyOwner {\n        maxTransactionSizePercent = Percent.encode(numerator, denominator);\n    }\n\n    function setSellAccumulationFee(uint128 numerator, uint128 denominator) external onlyOwner {\n        sellAccumulationFee = Percent.encode(numerator, denominator);\n        require(sellAccumulationFee.lte(initialSellAccumulationFee), \"Ledgity: fee too high\");\n    }\n\n    function setSellAtSmallPriceAccumulationFee(uint128 numerator, uint128 denominator) external onlyOwner {\n        sellAtSmallPriceAccumulationFee = Percent.encode(numerator, denominator);\n        require(sellAtSmallPriceAccumulationFee.lte(initialSellAtSmallPriceAccumulationFee), \"Ledgity: fee too high\");\n    }\n\n    function setSellReflectionFee(uint128 numerator, uint128 denominator) external onlyOwner {\n        sellReflectionFee = Percent.encode(numerator, denominator);\n        require(sellReflectionFee.lte(initialSellReflectionFee), \"Ledgity: fee too high\");\n    }\n\n    function setBuyAccumulationFee(uint128 numerator, uint128 denominator) external onlyOwner {\n        buyAccumulationFee = Percent.encode(numerator, denominator);\n        require(buyAccumulationFee.lte(initialBuyAccumulationFee), \"Ledgity: fee too high\");\n    }\n\n    function burn(uint256 amount) external override returns (bool) {\n        _burn(_msgSender(), amount);\n        return true;\n    }\n\n    function getDexes() external view returns (address[] memory) {\n        return _dexes.values;\n    }\n\n    function getExcludedFromDexFee() external view returns (address[] memory) {\n        return _excludedFromDexFee.values;\n    }\n\n    function getExcludedFromLimits() external view returns (address[] memory) {\n        return _excludedFromLimits.values;\n    }\n\n    function isDex(address account) public view returns (bool) {\n        return _dexes.has(account);\n    }\n\n    function isExcludedFromDexFee(address account) public view returns (bool) {\n        return _excludedFromDexFee.has(account);\n    }\n\n    function isExcludedFromLimits(address account) public view returns (bool) {\n        return _excludedFromLimits.has(account);\n    }\n\n    function _calculateReflectionFee(address sender, address recipient, uint256 amount) internal override view returns (uint256) {\n        if (isDex(recipient) && !isExcludedFromDexFee(sender)) {\n            return sellReflectionFee.mul(amount);\n        }\n        return 0;\n    }\n\n    function _calculateAccumulationFee(address sender, address recipient, uint256 amount) internal override view returns (uint256) {\n        if (isDex(sender) && !isExcludedFromDexFee(recipient)) {\n            return buyAccumulationFee.mul(amount);\n        }\n        if (isDex(recipient) && !isExcludedFromDexFee(sender)) {\n            if (_getPrice() >= initialPrice.mul(10)) {\n                return sellAccumulationFee.mul(amount);\n            } else {\n                return sellAtSmallPriceAccumulationFee.mul(amount);\n            }\n        }\n        return 0;\n    }\n\n    function _swapAndLiquifyOrCollect(uint256 contractTokenBalance) private lockTheSwap {\n        _transfer(address(this), address(reserve), contractTokenBalance);\n        if (feeDestination == FeeDestination.Liquify) {\n            reserve.swapAndLiquify(contractTokenBalance);\n        } else if (feeDestination == FeeDestination.Collect) {\n            reserve.swapAndCollect(contractTokenBalance);\n        } else {\n            revert(\"Ledgity: invalid feeDestination\");\n        }\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\n        if (!isExcludedFromLimits(sender) && isDex(recipient)) {\n            // No need for revert strings because they will be ignored by uniswap's `TransferHelper`\n            require(lastTransactionAt[sender] < block.timestamp.sub(10 minutes));\n            require(amount <= _maxTransactionSize());\n        }\n        lastTransactionAt[sender] = block.timestamp;\n\n        if (address(priceOracle) != address(0)) {\n            priceOracle.tryUpdate();\n        }\n\n        super._transfer(sender, recipient, amount);\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        if (\n            contractTokenBalance >= numTokensToSwap &&\n            !inSwapAndLiquify &&\n            sender != address(uniswapV2Pair)\n        ) {\n            if (contractTokenBalance > numTokensToSwap) {\n                contractTokenBalance = numTokensToSwap;\n            }\n            _swapAndLiquifyOrCollect(contractTokenBalance);\n        }\n    }\n\n    function _getPrice() private view returns (uint256) {\n        if (address(priceOracle) == address(0)) {\n            return 0;\n        }\n        return priceOracle.consult(address(this), 1e18);\n    }\n\n    function _maxTransactionSize() private view returns (uint256) {\n        return maxTransactionSizePercent.mul(totalSupply());\n    }\n}\n"
    },
    "contracts/libraries/ReflectToken.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./Context.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract ReflectToken is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n\n    uint8 private constant _decimals = 18;\n    uint256 private _tTotal;\n    uint256 private _rTotal;\n    uint256 private _tFeeTotal;\n\n    string private _name;\n    string private _symbol;\n\n    constructor (string memory name_, string memory symbol_, uint256 tTotal_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _tTotal = tTotal_;\n        uint256 MAX = type(uint256).max;\n        _rTotal = (MAX - (MAX % _tTotal));\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    /**\n     * @dev Amount of tokens to be charged as a reflection fee. Must be in range 0..amount.\n     */\n    function _calculateReflectionFee(address sender, address recipient, uint256 amount) internal virtual view returns (uint256);\n\n    /**\n     * @dev Amount of tokens to be charged and stored in this contract. Must be in range 0..amount.\n     */\n    function _calculateAccumulationFee(address sender, address recipient, uint256 amount) internal virtual view returns (uint256);\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ReflectToken: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ReflectToken: decreased allowance below zero\"));\n        return true;\n    }\n\n    function getExcluded() external view returns (address[] memory) {\n        return _excluded;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() external view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) external {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"ReflectToken: excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,,) = _getValues(sender, address(0), tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\n        require(tAmount <= _tTotal, \"ReflectToken: amount must be less than supply\");\n        address sender = _msgSender();\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,,,) = _getValues(sender, address(0), tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,,,) = _getValues(sender, address(0), tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"ReflectToken: amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) public onlyOwner() {\n        require(!_isExcluded[account], \"ReflectToken: account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) public onlyOwner() {\n        require(_isExcluded[account], \"ReflectToken: account is already included\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ReflectToken: approve from the zero address\");\n        require(spender != address(0), \"ReflectToken: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _burn(address from, uint256 tAmount) internal {\n        uint256 rAmount = tAmount.mul(_getRate());\n        _rOwned[from] = _rOwned[from].sub(rAmount, \"ReflectToken: burn amount is more than the balance\");\n        if (_isExcluded[from]) {\n            _tOwned[from] = _tOwned[from].sub(tAmount, \"ReflectToken: burn amount is more than the balance\");\n        }\n\t\t_rTotal = _rTotal.sub(rAmount);\n\t\t_tTotal = _tTotal.sub(tAmount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 tAmount) internal virtual {\n        require(sender != address(0), \"ReflectToken: transfer from the zero address\");\n        require(recipient != address(0), \"ReflectToken: transfer to the zero address\");\n        require(tAmount > 0, \"ReflectToken: transfer amount must be greater than zero\");\n\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 rAccumulation, uint256 tTransferAmount, uint256 tFee, uint256 tAccumulation) = _getValues(sender, recipient, tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        if (_isExcluded[sender]) {\n            _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        }\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        if (_isExcluded[recipient]) {\n            _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        }\n        _reflectFee(rFee, tFee);\n        _accumulateFee(rAccumulation, tAccumulation);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _accumulateFee(uint256 rAccumulation, uint256 tAccumulation) private {\n        _rOwned[address(this)] = _rOwned[address(this)].add(rAccumulation);\n        if(_isExcluded[address(this)]) {\n            _tOwned[address(this)] = _tOwned[address(this)].add(tAccumulation);\n        }\n    }\n\n    function _getValues(address sender, address recipient, uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tAccumulation) = _getTValues(sender, recipient, tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 rAccumulation) = _getRValues(tAmount, tFee, tAccumulation);\n        return (rAmount, rTransferAmount, rFee, rAccumulation, tTransferAmount, tFee, tAccumulation);\n    }\n\n    function _getTValues(address sender, address recipient, uint256 tAmount) private view returns (uint256, uint256, uint256) {\n        uint256 tFee = _calculateReflectionFee(sender, recipient, tAmount);\n        uint256 tAccumulation = _calculateAccumulationFee(sender, recipient, tAmount);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tAccumulation);\n        return (tTransferAmount, tFee, tAccumulation);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tAccumulation) private view returns (uint256, uint256, uint256, uint256) {\n        uint256 currentRate = _getRate();\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rAccumulation = tAccumulation.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rAccumulation);\n        return (rAmount, rTransferAmount, rFee, rAccumulation);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}\n"
    },
    "contracts/libraries/Percent.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./SafeMath.sol\";\n\n\nlibrary Percent {\n    using SafeMath for uint256;\n\n    struct Percent {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    function encode(uint128 numerator, uint128 denominator) internal pure returns (Percent memory) {\n        require(numerator <= denominator, \"Percent: invalid percentage\");\n        return Percent(numerator, denominator);\n    }\n\n    function mul(Percent memory self, uint256 value) internal pure returns (uint256) {\n        return value.mul(uint256(self.numerator)).div(uint256(self.denominator));\n    }\n\n    function lte(Percent memory self, Percent memory other) internal pure returns (bool) {\n        return uint256(self.numerator).mul(other.denominator) <= uint256(other.numerator).mul(self.denominator);\n    }\n}\n"
    },
    "contracts/libraries/Set.sol": {
      "content": "pragma solidity ^0.6.12;\n\n\nlibrary Set {\n    /// @title Set data structure\n    /// @dev Supports `add`, `remove` and `has` methods. Use `values` property to iterate over values. Do not edit properties directly.\n    struct AddressSet {\n        address[] values;\n        mapping(address => uint256) _valueIndexPlusOne;\n    }\n\n    /// @dev Adds a value to the set.\n    /// @return `true` if the value was successfully added; `false` if the value was already in the set.\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (set._valueIndexPlusOne[value] != 0) {\n            return false;\n        }\n\t\tset.values.push(value);\n\t\tset._valueIndexPlusOne[value] = set.values.length;  // length == last_index + 1\n        return true;\n    }\n\n    /// @dev Removes a value from the set.\n    /// @return `true` if value was successfully removed; `false` if the value was not in the set.\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        if (set._valueIndexPlusOne[value] == 0) {\n            return false;\n        }\n        uint256 valueToRemoveIndexPlusOne = set._valueIndexPlusOne[value];\n        uint256 lastValueIndex = set.values.length - 1;\n\n        // Swap indices\n        set._valueIndexPlusOne[set.values[lastValueIndex]] = valueToRemoveIndexPlusOne;\n        delete set._valueIndexPlusOne[value];\n\n        // Move the last value to the deleted spot\n        set.values[valueToRemoveIndexPlusOne - 1] = set.values[lastValueIndex];\n\n        // Delete the duplicated last value\n        set.values.pop();\n        return true;\n    }\n\n    /// @dev Checks if a value is in the set.\n    /// @return `true` if the value is in the set; `false` if the value is not in the set.\n    function has(AddressSet storage set, address value) internal view returns (bool) {\n        return set._valueIndexPlusOne[value] != 0;\n    }\n}\n"
    },
    "contracts/interfaces/ILedgityPriceOracle.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface ILedgityPriceOracle {\n    /**\n     * @dev Update average price.\n     * @return `true` if update successful; `false` if period has not yet elapsed.\n     */\n    function tryUpdate() external returns (bool);\n\n    /**\n     * @dev Update average price. Reverts if period has not yet elapsed.\n     */\n    function update() external;\n\n    /**\n     * @dev Returns the price of tokens.\n     */\n    function consult(address token, uint amountIn) external view returns (uint amountOut);\n}\n"
    },
    "contracts/LedgityPriceOracle.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport './interfaces/IUniswapV2Factory.sol';\nimport './interfaces/IUniswapV2Pair.sol';\nimport './interfaces/ILedgityPriceOracle.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\nimport './libraries/SafeMath.sol';\nimport './libraries/Ownable.sol';\nimport './libraries/UniswapV2OracleLibrary.sol';\n\n// fixed window oracle that recomputes the average price for the entire period once every period\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\ncontract LedgityPriceOracle is ILedgityPriceOracle, Ownable {\n    using FixedPoint for *;\n\n    uint public period = 12 hours;\n\n    IUniswapV2Pair pair;\n    address public immutable token0;\n    address public immutable token1;\n\n    uint    public price0CumulativeLast;\n    uint    public price1CumulativeLast;\n    uint32  public blockTimestampLast;\n    FixedPoint.uq112x112 public price0Average;\n    FixedPoint.uq112x112 public price1Average;\n\n    constructor(address pair_) public {\n        IUniswapV2Pair _pair = IUniswapV2Pair(pair_);\n        pair = _pair;\n        token0 = _pair.token0();\n        token1 = _pair.token1();\n        changePeriod(12 hours);\n    }\n\n    function update() external override {\n        require(tryUpdate(), 'LedgityPriceOracle: PERIOD_NOT_ELAPSED');\n    }\n\n    function tryUpdate() public override returns (bool) {\n        uint32 timeElapsed = UniswapV2OracleLibrary.currentBlockTimestamp() - blockTimestampLast; // overflow is desired\n        // ensure that at least one full period has passed since the last update\n        if (timeElapsed < period) {\n            return false;\n        }\n\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\n\n        price0CumulativeLast = price0Cumulative;\n        price1CumulativeLast = price1Cumulative;\n        blockTimestampLast = blockTimestamp;\n        return true;\n    }\n\n    // note this will always return 0 before update has been called successfully for the first time.\n    function consult(address token, uint amountIn) external view override returns (uint amountOut) {\n        if (token == token0) {\n            amountOut = price0Average.mul(amountIn).decode144();\n        } else {\n            require(token == token1, 'LedgityPriceOracle: INVALID_TOKEN');\n            amountOut = price1Average.mul(amountIn).decode144();\n        }\n    }\n\n    function changePeriod(uint256 _period) public onlyOwner {\n        require(_period > 0, 'LedgityPriceOracle: INVALID_PERIOD');\n        period = _period;\n        price0CumulativeLast = pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\n        price1CumulativeLast = pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\n        uint112 reserve0;\n        uint112 reserve1;\n        (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, 'LedgityPriceOracle: NO_RESERVES'); // ensure that there's liquidity in the pair\n        price0Average = FixedPoint.encode(reserve1).divuq(FixedPoint.encode(reserve0));\n        price1Average = FixedPoint.encode(reserve0).divuq(FixedPoint.encode(reserve1));\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.4.0;\n\nimport './FullMath.sol';\nimport './Babylonian.sol';\nimport './BitMath.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, 'FixedPoint::muli: overflow');\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= uint144(-1)) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '../interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.4.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\n\n        r = 255;\n        if (x & uint128(-1) > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & uint64(-1) > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & uint32(-1) > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & uint16(-1) > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & uint8(-1) > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "contracts/Timelock.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"./libraries/Ownable.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC20.sol\";\n\n\ncontract Timelock is Ownable {\n    using SafeMath for uint256;\n\n    uint256 public unlockAt;\n\n    modifier unlocked {\n        require(block.timestamp >= unlockAt, \"Timelock: locked\");\n        _;\n    }\n\n    constructor (uint256 delay) public {\n        unlockAt = block.timestamp.add(delay);\n    }\n\n    function withdraw(address token, uint256 amount) external onlyOwner unlocked {\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n    }\n\n    function setDelay(uint256 delay) external onlyOwner unlocked {\n        unlockAt = block.timestamp.add(delay);\n    }\n}\n"
    },
    "contracts/_mock/SetWrapper.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport \"../libraries/Set.sol\";\n\n/// @dev Wrapper for testing.\ncontract SetWrapper {\n    using Set for Set.AddressSet;\n\n    Set.AddressSet private set;\n\n    bool public lastAction;\n\n    function values() public view returns (address[] memory) {\n        return set.values;\n    }\n\n    function add(address value) public {\n        lastAction = set.add(value);\n    }\n\n    function remove(address value) public {\n        lastAction = set.remove(value);\n    }\n\n    function has(address value) public view returns (bool) {\n        return set.has(value);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}